import sys
import hashlib
import requests
import base64
import os
import json
import argparse

from web3 import Web3

# import auditee


def gen_ca_bundle(ca_bundle_path=None,
                    timeserver_ca_url=["https://letsencrypt.org/certs/lets-encrypt-r3.pem"],
                    ccf_crt_dir=None,
                    ccf_crt_files=None,
                    args=None):
    ccf_ca_def = ""
    if args is None:
        # doing this here to prevent unnecessary dependency on constants.py
        from constants import CCF_ENABLE,PROJECT_ROOT,CCF_CERTS_DIR
        ccf_enable = CCF_ENABLE
        if ccf_enable:
            if ccf_crt_dir is None and ccf_crt_files is None:
                ccf_crt_files = [os.path.join(CCF_CERTS_DIR, f) for f in files if "nodecert" in f]
            if ca_bundle_path is None:
                ca_bundle_path = os.path.join(PROJECT_ROOT, "enclave", "ca_bundle.h")
    else:
        ccf_crt_dir = args.ccf_directory
        ccf_crt_files = args.ccf_files
        ca_bundle_path = args.ca_bundle_path
        timeserver_ca_url = args.timeserver_ca_url
        ccf_enable = args.ccf_enable.lower() == "true" or args.ccf_enable == "1"

    if ccf_enable:
        if ccf_crt_dir is None and ccf_crt_files is None:
            exit(1, "--ccf-directory or --ccf-files is required when --ccf-enable set to 1 or true")
        if ccf_crt_dir is not None:
            files = os.listdir(ccf_crt_dir)
            ccf_crt_files = [os.path.join(ccf_crt_dir, f) for f in files if "nodecert" in f]
        for cert in ccf_crt_files:
            with open(cert) as f:
                ccf_ca_buff = f.read().replace("\n", "\\n")
            ccf_ca_def += ccf_ca_buff + "\" \\\n\""
    else:
        print("Not adding CCF certs")
    response = requests.get(timeserver_ca_url)
    timeserver_ca_buff = response.content.decode("utf-8")
    timeserver_ca_def = timeserver_ca_buff.replace("\n", "\\n")
    header_buff = f'''// THIS FILE IS GENERATED BY utils.py gen_ca_bundle DONT EDIT.\n
#ifndef TRUSTED_CERTS_H
#define TRUSTED_CERTS_H   
 
#define default_ca_bundle \"{timeserver_ca_def}\\0\"

#define ccf_ca_bundle \"{ccf_ca_def}\\0\"

#endif

'''
    print(header_buff)
    with open(ca_bundle_path, "w") as f:
        f.write(header_buff)


def swap_endians(b, *, length=32, from_byteorder="little", to_byteorder="big"):
    return int.from_bytes(b, from_byteorder).to_bytes(length, to_byteorder)


def verify_ias_report(report, report_key, report_sig):
    pass


def convert_publickey_address(publickey):
    if type(publickey) == str:
        if publickey[:2] == "0x":
            publickey = publickey[2:]
        publickey = bytes.fromhex(publickey)
    if len(publickey) == 65:
        publickey = publickey[1:]
    h = Web3.sha3(primitive=publickey)
    return Web3.toChecksumAddress(Web3.toHex(h[-20:]))


def get_packed_address(address):
    if address[:2] == "0x":
        address = address[2:]
    return bytes.fromhex(address).rjust(32, b'\0')


def get_address_from_packed(address):
    return Web3.toChecksumAddress(address[-20:].hex())


def get_cert_fingerprint(cert):
    cert = cert.lstrip("-----BEGIN CERTIFICATE-----\n").rstrip('\n-----END CERTIFICATE-----\n')
    public_bytes = base64.b64decode(cert)
    return sha256(public_bytes).hex()


# def verify_ias_report():
#     with open(QUOTE_FILE_PATH, "rb") as f:
#         quote_bytes = f.read()
#     quote_b64 = base64.b64encode(quote_bytes)
#     quote_dict = {"isvEnclaveQuote": quote_b64.decode()}
#     headers = {
#         "Content-Type": "application/json",
#         "Ocp-Apim-Subscription-Key": IAS_PRIMARY_KEY,
#     }
#     print("[biPVRA] Sending quote to Intel's Attestation Service for verification ...")
#     res = requests.post(IAS_URL, json=quote_dict, headers=headers)
#     if res.ok:
#         print(f"[biPVRA] Attestation report verification succeeded!")
#     else:
#         sys.exit(
#             f"Attestatin verification failed, with status: "
#             f"{res.status_code} and reason: {res.reason}\n"
#             f"Did you set SGX_SPID and IAS_PRIMARY_KEY?\n"
#             "See https://github.com/sbellem/sgx-iot#set-environment-variables{term.normal}"
#         )
#     ias_report = {"body": res.json(), "headers": dict(res.headers)}
#     with open(IAS_REPORT_PATH, "w") as f:
#         json.dump(ias_report, f)
#     print(
#         f"[biPVRA] Verify reported MRENCLAVE against trusted source code ..."
#     )
#     match = auditee.verify_mrenclave(PROJECT_ROOT, SIGNED_ENCLAVE_PATH, ias_report=IAS_REPORT_PATH,)
#     print(
#         f"[biPVRA] MRENCLAVE of remote attestation report does not match trusted source code."
#     )
#     print(f"[biPVRA] Extracting public key from IAS report ...")
#     quote_body = res.json()["isvEnclaveQuoteBody"]
#     report_data = base64.b64decode(quote_body)[368:432]
#     x_little = report_data[:32]
#     y_little = report_data[32:]
#     x = swap_endians(x_little, length=32, from_byteorder="little", to_byteorder="big")
#     y = swap_endians(y_little, length=32, from_byteorder="little", to_byteorder="big")
#     point = x + y
#     with open(SIGN_KEY_PATH, "wb") as f:
#         f.write(point)


def print_hex_trunc(val):
    if type(val) == bytes:
        val = val.hex()
    if val[:2] == "0x":
        val = val[2:]
    l = min(3, int(len(val)/2))
    return "0x" + val[:l]+"..."+val[-l:]


def sha256(data):
    return hashlib.sha256(data).digest()


def sha3(data):
    # m = hashlib.sha3_256()
    # m.update(data)
    # return m.digest()
    return Web3.sha3(primitive=data)


if __name__ == '__main__':
    if len(sys.argv) > 1 and sys.argv[1] == "gen_ca_bundle":
        parser = argparse.ArgumentParser(prog="gen_ca_bundle", 
        description="Generates ca_bundle.h file with hardocded certificates for time server and CCF network nodes.")
        parser.add_argument("gen_ca_bundle")
        parser.add_argument("-p", "--ca-bundle-path", type=str, 
                                default="enclave/ca_bundle.h",
                                help="Path to generate file in")
        parser.add_argument("-t", "--timeserver-ca-url", 
                                type=str, action='append', 
                                default="https://letsencrypt.org/certs/lets-encrypt-r3.pem",
                                help="Urls where time server certificates can be downloaded.")
        parser.add_argument("-ccf-enable", type=str, default="1", help="Whether or not to add CCF certificates")
        parser.add_argument("-cd", "--ccf-directory", type=str, help="Directory containing CCF node certs. Will automatically add any files with nodecert in the name.")
        parser.add_argument("-cf", "--ccf-files", type=str, action='append', 
                                    default=["shared/ccf_sandbox/nodecert0.pem", "shared/ccf_sandbox/nodecert1.pem", "shared/ccf_sandbox/nodecert2.pem"], 
                                    help="directory containing CCF node certs.")
        args = parser.parse_args()
        gen_ca_bundle(args=args)
    if len(sys.argv) == 2:
        globals()[sys.argv[1]]()
    elif len(sys.argv) == 3:
        globals()[sys.argv[1]](sys.argv[2])
    elif len(sys.argv) == 4:
        globals()[sys.argv[1]](sys.argv[2], sys.argv[3])
    elif len(sys.argv) == 5:
        globals()[sys.argv[1]](sys.argv[2], sys.argv[3], sys.argv[4])

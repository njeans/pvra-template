import sys
import hashlib
import requests
import base64
import os

from web3 import Web3

import auditee


def gen_ca_bundle(ccf_crt_path=None, ca_bundle_path=None, timeserver_ca_url=None):
    if ccf_crt_path is None:  # doing this to prevent cirular imports utils.py & constants.py 
        from constants import CCF_NODE_CERT_PATH
        ccf_crt_path=CCF_NODE_CERT_PATH
    if ca_bundle_path is None:
        from constants import PROJECT_ROOT
        ca_bundle_path=os.path.join(PROJECT_ROOT, "enclave", "ca_bundle.h")
    if timeserver_ca_url is None:
        timeserver_ca_url = "https://letsencrypt.org/certs/lets-encrypt-r3.pem"
    response = requests.get(timeserver_ca_url)
    timeserver_ca_buff = response.content.decode("utf-8")
    timeserver_ca_def = timeserver_ca_buff.replace("\n", "\\n")
    with open(ccf_crt_path) as f:
        ccf_ca_buff = f.read()
    ccf_ca_def = ccf_ca_buff.replace("\n", "\\n")
    header_buff = f'''// THIS FILE IS GENERATED BY gen_ca_bundle.py. DONT EDIT.\n
#ifndef TRUSTED_CERTS_H
#define TRUSTED_CERTS_H   
 
#define default_ca_bundle \"{timeserver_ca_def}\\0\"

#define ccf_ca_bundle \"{ccf_ca_def}\\0\"

#endif

'''
    print(header_buff)
    with open(ca_bundle_path, "w") as f:
        f.write(header_buff)


def swap_endians(b, *, length=32, from_byteorder="little", to_byteorder="big"):
    return int.from_bytes(b, from_byteorder).to_bytes(length, to_byteorder)


def verify_ias_report(report, report_key, report_sig):
    pass


def convert_publickey_address(publickey):
    if type(publickey) == str:
        if publickey[:2] == "0x":
            publickey = publickey[2:]
        publickey = bytes.fromhex(publickey)
    if len(publickey) == 65:
        publickey = publickey[1:]
    h = Web3.sha3(primitive=publickey)
    return Web3.toChecksumAddress(Web3.toHex(h[-20:]))


def get_packed_address(address):
    if address[:2] == "0x":
        address = address[2:]
    return bytes.fromhex(address).rjust(32, b'\0')


def get_address_from_packed(address):
    return Web3.toChecksumAddress(address[-20:].hex())


def get_cert_fingerprint(cert):
    cert = cert.lstrip("-----BEGIN CERTIFICATE-----\n").rstrip('\n-----END CERTIFICATE-----\n')
    public_bytes = base64.b64decode(cert)
    return sha256(public_bytes).hex()


def verify_ias_report():
    with open(QUOTE_FILE_PATH, "rb") as f:
        quote_bytes = f.read()
    quote_b64 = base64.b64encode(quote_bytes)
    quote_dict = {"isvEnclaveQuote": quote_b64.decode()}
    headers = {
        "Content-Type": "application/json",
        "Ocp-Apim-Subscription-Key": IAS_PRIMARY_KEY,
    }
    print("[biPVRA] Sending quote to Intel's Attestation Service for verification ...")
    res = requests.post(IAS_URL, json=quote_dict, headers=headers)
    if res.ok:
        print(f"[biPVRA] Attestation report verification succeeded!")
    else:
        sys.exit(
            f"Attestatin verification failed, with status: "
            f"{res.status_code} and reason: {res.reason}\n"
            f"Did you set SGX_SPID and IAS_PRIMARY_KEY?\n"
            "See https://github.com/sbellem/sgx-iot#set-environment-variables{term.normal}"
        )
    ias_report = {"body": res.json(), "headers": dict(res.headers)}
    with open(IAS_REPORT_PATH, "w") as f:
        json.dump(ias_report, f)
    print(
        f"[biPVRA] Verify reported MRENCLAVE against trusted source code ..."
    )
    match = auditee.verify_mrenclave(PROJECT_ROOT, SIGNED_ENCLAVE_PATH, ias_report=IAS_REPORT_PATH,)
    print(
        f"[biPVRA] MRENCLAVE of remote attestation report does not match trusted source code."
    )
    print(f"[biPVRA] Extracting public key from IAS report ...")
    quote_body = res.json()["isvEnclaveQuoteBody"]
    report_data = base64.b64decode(quote_body)[368:432]
    x_little = report_data[:32]
    y_little = report_data[32:]
    x = swap_endians(x_little, length=32, from_byteorder="little", to_byteorder="big")
    y = swap_endians(y_little, length=32, from_byteorder="little", to_byteorder="big")
    point = x + y
    with open(SIGN_KEY_PATH, "wb") as f:
        f.write(point)


def print_hex_trunc(val):
    if type(val) == bytes:
        val = val.hex()
    if val[:2] == "0x":
        val = val[2:]
    l = min(3, int(len(val)/2))
    return "0x" + val[:l]+"..."+val[-l:]


def sha256(data):
    return hashlib.sha256(data).digest()


def sha3(data):
    # m = hashlib.sha3_256()
    # m.update(data)
    # return m.digest()
    return Web3.sha3(primitive=data)


if __name__ == '__main__':
    if len(sys.argv) == 2:
        globals()[sys.argv[1]]()
    elif len(sys.argv) == 3:
        globals()[sys.argv[1]](sys.argv[2])
    elif len(sys.argv) == 4:
        globals()[sys.argv[1]](sys.argv[2], sys.argv[3])
    elif len(sys.argv) == 5:
        globals()[sys.argv[1]](sys.argv[2], sys.argv[3], sys.argv[4])
